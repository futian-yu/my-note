java多线程

​	**线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。

- 创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。
- 就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。
- 运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。
- 阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。
- 死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 　　



**并行**：多个cpu同时执行多个任务。

**并发**：一个cpu(采用时间片)“同时”执行多个任务

​		1.我们不能通过run()的方式启动线程，

​		 2.再启动一个线程，不可以让已经启动的线程去start

​			（要想启动多个线程，就要造多个对象）



**线程的常用方法：**

​	yield():释放当前cpu的执行权，下一刻cpu执行权可能分配给你，也可能不分配给你，看切换的速度等；

​	join(): 在线程a中调用线程b的join(),此时线程a就

进入阻塞状态，直到线程b完全执行后，线程a才结束阻塞状态；顾名思义。

  stop(): 强制线程生命结束，不推荐；	

  sleep():(子类重写的方法抛的异常不能比父类更大)，让当前线程“睡眠”指定的milltime毫秒，。

在指定的millitime毫秒时间内，当前线程是阻塞状态；

 isAlive():判断当前线程是否存活。



**线程的优先级：**

MAX_PRIORITY  10;

MIN_PRIORITY	1;

NORM_PRIORITY	5;

2.如何获取和设置当前线程的优先级：

​	getPriority();	获取线程的优先级

​	setPriority(int p);	设置线程的优先级；

说明：高优先级的线程要抢占低优先级线程的cpu执行权。但是只是从概率上讲，高优先级的线程高概率被执行。并不意味着只有当高优先级的线程执行完后，低优先级的线程才执行；

**3.**

- **多线程的创建**，方式一：继承于Thread类

1)创建一个继承于Thread类的子类

2）重写Thread类的run() --> 将此线程执行的操作

声明在run()中

3).创建Thread类的子类的对象

4) 通过此对象调用start()



- 创建多线程的方式二:实现Runnable接口	

1)创建一个实现了Runnable接口的类

2)实现类去实现Runnable中的抽象方法:run()

3)创建实现类的对象

4)将此对象作为参数传递到Thread类的构造器中，

创建Thread类的对象

5)通过Thread类的对象调用start()



- 比较两种创建方式；

  开发中：优先选择，实现Runnable接口的方式，原因：1.实现的方式没有类的单继承的局限性。

  2.实现的方式更适合来处理多个线程有共享数据的情况，联系：public class Thread implements Runnable相同点：两种方式都要重写run()，将线程要执行的逻辑声明在run()中；



**java线程池****

线程池：为了提高利用率，和jdbc连接池一样。

1.线程和任务分离，提升线程重用性；

2.控制线程并发数量，降低服务器压力，统一管理所有线程/

3.提升系统的响应速度，减少创建和销毁线程的时间；



shotdown():关闭线程池，仅仅是不再接收新的任务，

以前的任务还会继续执行；

shutdownNow():立刻关闭线程池，如果线程池中还有缓存的

任务没有执行，则取消执行，并返回这些任务

java内置线程池；延迟时间，延迟时间； 



ScheduledExecutorService是ExecutorService的子接口，

具备了延迟运行或定期执行任务的能力。



**线程池的使用步骤总结(5步):**

​	1.利用Executors工厂类的静态方法，创建线程池对象；

​	2.编写Runnable或Callable实现类的实例对象；

​	3.利用ExecutorService的submit方法或ScheduledExecutorService的

schedule方法提交并执行线程任务；

​	4.如果又执行结果，则处理异步执行结果(Future)

​	5.调用shutdown()方法，关闭线程池；