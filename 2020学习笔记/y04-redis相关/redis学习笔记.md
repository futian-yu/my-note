**redis学习笔记**

1.Nosql概述

​	spring clound 2004年发布，hadoop 2006年发布

​	泛指非关系型数据库的，随着web2.0互联网的诞生！传统的关系型数据库很难对付web2.0时代！（视频，地图，位置）尤其是超大规模的高并发的社区！暴露出来很多难以克服的问题，NoSql在当今大数据环境下发展的十分迅速，Redis是发展最快的，而且是我们当下必须要掌握的一个技术！

​	很多的数据类型，用户的个人信息，社交网络，地理位置。这些数据类型的存储不需要一个固定的格式！

2. NoSQL特点

   1）方便扩展(数据之间没有关系，很好扩展！)

   2）大数据量高性能(Redis一秒写8万次，读取11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高)

   3）数据类型是多样型的！(不需要实现设计数据库！随取随用！)

   

**redis基础知识：**

​	redis默认有16个数据库，进入配置文件进行查看：

![image-20200905173229295](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200905173229295.png)

默认使用的是第0个

可以使用select进行切换；

Redis是单线程的！

Redis是基于内存操作，cpu不是Reids性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了；

Redis是C语言写的，官方提供的数据为100000+的QPS，完全不比同样是key-value的Memecache差！

**Reids为什么单线程还这么块！**

1.误区1：高性能的服务器一定是多线程的？

2.误区2：多线程(CPU上下文会切换！)一定比单线程效率高！

​	CPU>内存>硬盘的速度有所了解

核心：redis是将所有数据全部放在内存中的，所以说使用单线程的效率是最高的，多线程(CPU会进行上下文切换，耗时操作！)，对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳方案；



1).String 类型字符串：

​	setex，setnx，ttl等命令;

2).List

​	在redis里面，我们可以把list玩成，栈，队列，阻塞队列！

​	所有的list命令都是用 l 来开头

3).Set

4).Hash(哈希)

相当于一个M

5）Zset（有序集合）

三种特殊数据类型

​		geospatial 地理位置

​		hyperloglog	基数（不重复的元素） ,可以接收误差！

​		bitmaps:位存储(省内存)：如统计操作，统计打卡的天数！



**redis实现乐观锁**    watch  unwatch

​		

**Jedis**

​	Jedis相当于是一个操作redis的中间件（jar包）；



Redis.conf配置文件

​	1.配置文件unit单位  对大小写不敏感。

快照：持久化，在规定得时间内，执行了多少次操作，则会

持久化到文件.rdb.aof;(redis是内存数据库，如果没有持久化，那么数据断电即失)





**Redis持久化**

​	**持久化之RDB操作**	

![image-20200909233853685](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200909233853685.png)

​	eg: save 60 5      :表示只要60s内修改了5次key，就会触发rdb操作；

1.save的规则满足的情况下，会自动触发rdb规则；

2.执行flushall命令，也会触发我们的rdb规则！

3.推出redis，也会产生rdb文件！

​	备份就自动生成一个dump.rdb

如果恢复rdb文件！

​	1.只需将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb恢复其中的数据！

​	2.查看需要存在的位置

​	![image-20200909225450520](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200909225450520.png)

优点：

​	1.适合大规模的数据恢复！ dump

​	2.对数据的完整性要求不高！

缺点：

​	1.需要一定的时间间隔进行操作！如果redis意外宕机了，

这个最后一次修改数据就没有了！

​	2.fork进程的时候，会占用一定的内存空间！！



**reids持久化之AOF**

​	将我们的所有命令全部记录下来；它以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作！。

**Aof保存的是appendonly.aof文件**  默认是不开启的，需要手动修改配置

​	优点(三种情况下的)：

​		1.每一次修改都同步，文件的完整会更好

​		2.每秒同步一次，可能会丢失一秒的数据

​		3.从不同步，效率最高的

​	缺点：

​	1.相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢；

​	2.Aof运行效率也比rdb慢，所以我们redis默认配置就是rdb持久化；

注意：只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化；



Redis订阅发布

​	订阅：SUBSCRIBE channel [channel...]



redis主从复制(聊聊哨兵模式)

![image-20200910141331780](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200910141331780.png)![image-20200910141712210](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200910141712210.png)	单哨兵(哨兵要是挂了，就挂了)

![image-20200910142512886](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200910142512886.png)

多哨兵(哨兵之间互相监控)

![image-20200910142652460](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200910142652460.png)



![image-20200910142714519](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200910142714519.png)

哨兵配置文件：sentinel.conf   

哨兵模式优点：

​	1.哨兵集群，基于主从复制模式，所有的主从配置优点，它全有；

​	2.主从可以切换，故障可以转移，系统的可用性就会更好；

	3. 哨兵模式就是主从模式的升级，手动到自动，更加健壮！



缺点：

​	1.Redis不好在线扩容的，集群容量一旦达到上线，

​	2.实现哨兵模式的配置其实是很麻烦的，里面有很多选择！



**Redis缓存穿透和雪崩**

**缓存穿透**（查不到）

![image-20200910144331737](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200910144331737.png)

缓存中没有 user2，jmeter疯狂发请求user2，可以给数据库造成巨大压力；



解决方案：布隆过滤器

![image-20200910144526124](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200910144526124.png)

缓存空对象

![image-20200910144603399](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200910144603399.png)



**缓存击穿：**（量太大，缓存过期时！）

​	这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停地扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间! 持续的大并发就穿破缓存，直接砸向数据库，就像在屏障上凿了一个洞。

​	当这个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导致数据库瞬间压力过大。



**解决方案：**

​	**1.设置热点数据永不过期：**从缓存层面来看，没有设置过期时间，所以不会出现热点数据过期后的问题；

​	**2.加互斥锁：**使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的压力很大。



**缓存雪崩**		

缓存雪崩，是指在某一个时间段，缓存集中过期失效。redis宕机！

![image-20200910152929159](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200910152929159.png)



**解决高可用**

​	redis高可用（集群，异地多活！）

**限流降级**（停掉一些服务，加锁或者队列来控制读数据库写缓存的线程数量）

​	这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询和写缓存，其他线程等待。

**数据预热**

​	比如，在双十一热点商品发售前，我先把可能的数据预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。