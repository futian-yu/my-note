//战争论 ： 152

读书笔记：

1.StringBuilder是非线程安全的，StringBuffer是线程安全的，那么String字符串线程安全吗？

2.乐观锁总结一波；写个总结；

3.@Autowired注解；

4.**== 和 equals 的区别是什么**；

4.5 String为什么是不可变对象，解释一下。

5.**两个对象的 hashCode()相同，则 equals()也一定为 true吗？不一定

6.java的8种基础数据类型？  int,short,byte,boolen,Long,Double,Float,char

7.**java 中操作字符串都有哪些类？它们之间有什么区别？**

**8.String str="i"与 String str=new String("i")一样吗？**

9.String 类的常用方法都有那些？

10.**抽象类必须要有抽象方法吗？**  不需要，但抽象类不能直接实例化

11. **接口和抽象类有什么区别？**

    ​	实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。

    - 构造函数：抽象类可以有构造函数；接口不能有。
    - 实现数量：类可以实现很多个接口；但是只能继承一个抽象类。
    - 访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。

12. **java 中 IO 流分为几种**

    按功能来分：输入流（input）、输出流（output）。

    按类型来分：字节流和字符流。

    字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。

13.容器都有哪些？

![image-20200915142636679](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200915142636679.png)

14.**Collection 和 Collections 有什么区别**？

​		java.util.Collection 是一个集合**接口**（集合类的一个顶级接口），他提供了对集合对象进行基本操作的通用接口方法。

​		Collections则是集合类的一个工具**类**/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索、线程安全等各种操作。

15.List、Set、Map之间的区别是什么？

​	![image-20200915143254123](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200915143254123.png)

**21. HashMap 和 Hashtable 有什么区别？**

- hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。

- hashTable同步的，而HashMap是非同步的，效率上比hashTable要高。
- hashMap允许空键值，而hashTable不允许。

22.**如何决定使用 HashMap 还是 TreeMap？**

​		对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。

23.**说一下 HashMap 的实现原理**？

​	HashMap是基于哈希表的Map接口的非同步实现。并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。

​	当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根据hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。

24.**ArrayList 和 LinkedList 的区别是什么？**

​	 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。

​	使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。

25.**数组和 List 之间的转换方法**

- List转换成为数组：调用ArrayList的toArray方法。
- 数组转换成为List：调用Arrays的asList方法。

26**在 Queue 中 poll()和 remove()有什么区别？**

​	poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。

27.**哪些集合类是线程安全的？**

vector：就比arrayList多了个线程安全，但效率低，已经不太建议使用。

statck：堆栈类，先进后出。

hashtable：就比hashmap多了个线程安全。

enumeration：枚举，相当于迭代器。

**28.并行和并发有什么区别？**

​	并行：多核同时处理多个任务；

​	并行：单核处理多个任务，线程切换，轮流使用cpu；

29.**线程和进程的区别**

​	一个程序至少有一个进程，一个进程至少有一个线程。线程是cpu调度和分派的基本单位。

​	守护线程: 是一个为其他线程服务的线程。JVM退出时，不必关心守护线程是否已经结束。

30.**创建线程有哪几种方式？**

①. 继承Thread类创建线程类

​		定义Thread的子类，重写run()方法：执行体；

​		创建Thread子类的实例，即创建了线程对象；

​		调用线程对象的start()方法启动线程；

②. 通过Runnable接口创建线程类

​	定义Runnable接口的实现类，重写run()

​	创建Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象(Runnable接口的实现类的实例作为Thread类的构造函数参数)，该Thread对象才是真正的线程对象。

③. 通过Callable和Future创建线程	(常配合线程池使用)

- 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
- 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
- 使用FutureTask对象作为Thread对象的target创建并启动新线程。
- 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。

31.**说一下 runnable 和 callable 有什么区别？**

- Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；
- Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。

32.线程有哪些状态?

​	线程通常都有五种状态:创建、就绪、运行、阻塞和死亡。

33.sleep()和wait()有什么区别？

​	sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。（睡眠了，但是不释放机锁，其他线程不能访问该对象的synchronized代码块）

​	wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。（睡眠了，但是会释放机锁，其他线程可以访问该对象的synchronized代码块）

34.**notify()和 notifyAll()有什么区别？**

- 如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。
- 当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。
- 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。

35.创建线程池有哪几种方式？

​	①. newFixedThreadPool(int nThreads)

创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。

②. newCachedThreadPool()

创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。

③. newSingleThreadExecutor()

这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。

④. newScheduledThreadPool(int corePoolSize)

创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。

36.**线程池中 submit()和 execute()方法有什么区别？**

- 接收的参数不一样
- submit有返回值，而execute没有
- submit方便Exception处理

37.怎么防止死锁？

​	首先需要了解死锁产生的四个必要条件

- 互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
- 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放
- 不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放
- 环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。

理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。



38.**ThreadLocal 是什么？有哪些使用场景？**

​	线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。

39.说说synchronized底层实现原理？

synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。

Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：

- 普通同步方法，锁是当前实例对象
- 静态同步方法，锁是当前类的class对象
- 同步方法块，锁是括号里面的对象

40.**synchronized 和 Lock 有什么区别？**

​	synchronized是java内置关键字，在jvm层面，Lock是个java类；

41.**什么是 java 序列化？什么情况下需要序列化？**

​	简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。比如说当你想把内存中的对象状态保存到一个文件中或者数据库的时候，就需要java序列化。

42.**动态代理是什么？有哪些应用？**

​	动态代理：

​	当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。

​	动态代理的应用：Spring的AOP、加事务、加权限、加日志

43.怎么实现动态代理。

​	首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。	

44.深拷贝和浅拷贝的区别是什么？

 - 浅拷贝只是赋值了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝。
 - 深拷贝是将对象及值复制过来，两个对象修改其中任意一个值另一个值不会改变，这就是深拷贝。

**45. final、finally、finalize 有什么区别？**

​	final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。

​	finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。

​	finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。 



JAVA WEB 

1. jsp经编译后就变成了Servlet.

2. jsp九个内置对象：

   ​	request：封装客户端的请求，其中包含来自GTE和post请求的参数；

   ​	response：封装服务器对客户端的响应；

   ​	pageContext：通过该对象可以获取其他对象；

   ​	session：封装用户会话的对象；

   ​	application：封装服务器运行环境的对象；

   ​	out：输出服务器响应的输出流对象；

   ​	config：Web应用的配置对象；

   ​	page：JSP页面本身（相当于java程序中的this）；

   ​	exception：封装页面抛出异常的对象；

3.jsp的4种作用域；

​		page，request，session，application

4.session和cookie有什么区别？

​		实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID。总结：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

​		禁用Cookie就不能得到Session了。因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。





