# pagehelper 联表 分页查询性能优化 -- (sql允许先分页,后联表)

![img](https://csdnimg.cn/release/phoenix/template/new_img/original.png)

[JAVA地摊](https://me.csdn.net/hjl21) 2019-01-29 11:54:12 ![img](https://csdnimg.cn/release/phoenix/template/new_img/articleReadEyes.png) 4094 ![img](https://csdnimg.cn/release/phoenix/template/new_img/tobarCollect.png) 收藏 6

分类专栏： [mybatis](https://blog.csdn.net/hjl21/category_8054137.html) [数据库](https://blog.csdn.net/hjl21/category_7918496.html) [新增点](https://blog.csdn.net/hjl21/category_7763102.html)

版权

(https://blog.csdn.net/hjl21/article/details/86687424)

**优化的前提条件,分页的sql允许先分页,联表并不影响最后的结果集,只是补齐所需字段信息.**

一,pagehelper改造思路
     1,5.0.0以上版本支持手动count查询语句.详见 https://github.com/pagehelper/Mybatis-PageHelper/
     2,自定义拦截器,对有别名为"AS limitable" 的子查询sql进行sql拼接,将 本应拼接到末尾的limit ?,? 拼接到子查询sql末尾.
     3,重新定位入参的位置.将limit的参数从末尾调整到limit子查询语句的地方.
     4,用法,同pagehelper正常用法(版本要求5.0.4以上), 将pagehelper拦截器配置为自定义拦截器.

二,代码部分
    1,mapper

```xml
<!-- 分页条件查询  优化 -->	<select id="findUserCount" resultMap="BaseResultMap">		select limitable.openId as openId,		insert(limitable.mobile,4,4,'****')          AS mobile,		limitable.subscribeTime as subscribeTime,		limitable.unSubscribeTime as unSubscribeTime,		c.chanelName as chanelName		from		(select countBind.bindChannelId,countBind.openId,		countBind.mobile,countBind.subscribeTime,		countBind.unSubscribeTime,countBind.userTag		FROM countBind  		WHERE		countBind.countId = #{countId,jdbcType=INTEGER}		<if			test="userCountReq.unSubendTime != null and userCountReq.unSubendTime !=''">			and countBind.unSubscribeTime &lt;= #{userCountReq.unSubendTime}		</if>		<if			test="userCountReq.bindChannelIds != null and userCountReq.bindChannelIds.size()>0">			and countBind.bindChannelId in			<foreach collection="userCountReq.bindChannelIds" index="index"				item="idItem" open="(" separator="," close=")">				#{idItem}			</foreach>		</if>		<if test="userCountReq.tags != null and userCountReq.tags.size()>0">			and countBind.userTag in			<foreach collection="userCountReq.tags" index="index" item="tagItem"				open="(" separator="," close=")">				#{tagItem}			</foreach>		</if>		) AS limitable		left join		channel c		on		limitable.bindChannelId=c.channelId		where		c.countId = #{countId,jdbcType=INTEGER} 	</select>		<!-- 分页条件统计Count  优化-->	<select id="findUserCount_COUNT" resultType="java.lang.Integer">		select count(*)		from		countBind b				where		b.countId = #{countId,jdbcType=INTEGER}		<if			test="userCountReq.unSubendTime != null and userCountReq.unSubendTime !=''">			and b.unSubscribeTime &lt;= #{userCountReq.unSubendTime}		</if>		<if			test="userCountReq.bindChannelIds != null and userCountReq.bindChannelIds.size()>0">			and b.bindChannelId in			<foreach collection="userCountReq.bindChannelIds" index="index"				item="idItem" open="(" separator="," close=")">				#{idItem}			</foreach>		</if>		<if test="userCountReq.tags != null and userCountReq.tags.size()>0">			and b.userTag in			<foreach collection="userCountReq.tags" index="index" item="tagItem"				open="(" separator="," close=")">				#{tagItem}			</foreach>		</if>	</select>
```

​     2 pagehelper拦截器
 

```java
 /* * The MIT License (MIT) * * Copyright (c) 2014-2017 abel533@gmail.com * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */ import java.lang.reflect.Field;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.Properties; import org.apache.ibatis.cache.CacheKey;import org.apache.ibatis.executor.Executor;import org.apache.ibatis.mapping.BoundSql;import org.apache.ibatis.mapping.MappedStatement;import org.apache.ibatis.mapping.ParameterMapping;import org.apache.ibatis.plugin.Interceptor;import org.apache.ibatis.plugin.Intercepts;import org.apache.ibatis.plugin.Invocation;import org.apache.ibatis.plugin.Plugin;import org.apache.ibatis.plugin.Signature;import org.apache.ibatis.session.Configuration;import org.apache.ibatis.session.ResultHandler;import org.apache.ibatis.session.RowBounds; import com.github.pagehelper.Dialect;import com.github.pagehelper.PageException;import com.github.pagehelper.cache.Cache;import com.github.pagehelper.cache.CacheFactory;import com.github.pagehelper.util.MSUtils;import com.github.pagehelper.util.StringUtil; /** * 对pagehelper联表分页查询进行sql优化.(待优化sql的前提条件.可以先分页后联表) ,指定标识符"AS limitable" * 为分页标识的sql. 末尾带有 AS limitable 的子查询会拼接上limit进行先分页.然后再外联查询 *  * @author mumu/liuzh/abel533/isea533 * @version 5.0.0 */@SuppressWarnings({ "rawtypes", "unchecked" })@Intercepts({		@Signature(type = Executor.class, method = "query", args = { MappedStatement.class, Object.class,				RowBounds.class, ResultHandler.class }),		@Signature(type = Executor.class, method = "query", args = { MappedStatement.class, Object.class,				RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class }), })public class MumuPageInterceptor implements Interceptor {	//private static final Logger logger = LoggerFactory.getLogger(MumuPageInterceptor.class); 	// 缓存count查询的ms	protected Cache<String, MappedStatement> msCountMap = null;	private Dialect dialect;	private String default_dialect_class = "com.github.pagehelper.PageHelper";	private Field additionalParametersField;	private String countSuffix = "_COUNT"; 	@Override	public Object intercept(Invocation invocation) throws Throwable {		try {			Object[] args = invocation.getArgs();			MappedStatement ms = (MappedStatement) args[0];			Object parameter = args[1];			RowBounds rowBounds = (RowBounds) args[2];			ResultHandler resultHandler = (ResultHandler) args[3];			Executor executor = (Executor) invocation.getTarget();			CacheKey cacheKey;			BoundSql boundSql;			// 由于逻辑关系，只会进入一次			if (args.length == 4) {				// 4 个参数时				boundSql = ms.getBoundSql(parameter);				cacheKey = executor.createCacheKey(ms, parameter, rowBounds, boundSql);			} else {				// 6 个参数时				cacheKey = (CacheKey) args[4];				boundSql = (BoundSql) args[5];			}			List resultList;			// 调用方法判断是否需要进行分页，如果不需要，直接返回结果			if (!dialect.skip(ms, parameter, rowBounds)) {				// 反射获取动态参数				String msId = ms.getId();				Configuration configuration = ms.getConfiguration();				Map<String, Object> additionalParameters = (Map<String, Object>) additionalParametersField						.get(boundSql);				// 判断是否需要进行 count 查询				if (dialect.beforeCount(ms, parameter, rowBounds)) {					String countMsId = msId + countSuffix;					Long count;					// 先判断是否存在手写的 count 查询					MappedStatement countMs = getExistedMappedStatement(configuration, countMsId);					if (countMs != null) {						count = executeManualCount(executor, countMs, parameter, boundSql, resultHandler);					} else {						countMs = msCountMap.get(countMsId);						// 自动创建						if (countMs == null) {							// 根据当前的 ms 创建一个返回值为 Long 类型的 ms							countMs = MSUtils.newCountMappedStatement(ms, countMsId);							msCountMap.put(countMsId, countMs);						}						count = executeAutoCount(executor, countMs, parameter, boundSql, rowBounds, resultHandler);					}					// 处理查询总数					// 返回 true 时继续分页查询，false 时直接返回					if (!dialect.afterCount(count, parameter, rowBounds)) {						// 当查询总数为 0 时，直接返回空的结果						return dialect.afterPage(new ArrayList(), parameter, rowBounds);					}				}				// 判断是否需要进行分页查询				if (dialect.beforePage(ms, parameter, rowBounds)) {					// 生成分页的缓存 key					CacheKey pageKey = cacheKey;					// 处理参数对象					parameter = dialect.processParameterObject(ms, parameter, boundSql, pageKey);					// 调用方言获取分页 sql					String pageSql = dialect.getPageSql(ms, boundSql, parameter, rowBounds, pageKey);					// pageSql.toString());					/**					 * 对sql进行改造					 */					String changer = "";					int limitCount = 0;					if (pageSql.contains(PageSqlResolver.LIMIT_SIGN_EX)) {						changer = PageSqlResolver.LIMIT_SIGN_EX;						limitCount = 2;					} else if (pageSql.contains(PageSqlResolver.LIMIT_SIGN)) {						changer = PageSqlResolver.LIMIT_SIGN;						limitCount = 1;					}					pageSql = PageSqlResolver.resolveLimit(pageSql, changer);					List<ParameterMapping> parameterMappingList = boundSql.getParameterMappings();					// 参数调度					/** 参数偏移,需要调整limit 参数 */					if (pageSql.contains(PageSqlResolver.SQL_SIGN)) {						String sqlInCount = pageSql.substring(pageSql.indexOf(PageSqlResolver.SQL_SIGN));						// 统计limitable之后还有多少个?//						Integer count = 0;						for (int i = 0; i < sqlInCount.length(); i++) {							if (sqlInCount.indexOf("?", i) != -1) {								i = sqlInCount.indexOf("?", i);								count++;							}						}						// 获取临时的list						List<ParameterMapping> tempParameterMappingList = boundSql.getParameterMappings();						// count>0则 limit后面有参数,需要将limit的参数往前提						int size = tempParameterMappingList.size();						if (count > 0) {							// 只需要移动一个							if (limitCount == 1) {								// 获取最后一个参数								ParameterMapping p1 = tempParameterMappingList.remove(size - 1);								// 将参数插入到指定位置								tempParameterMappingList.add((size - 1 - count), p1);							}							// 需要移动两个							else if (limitCount == 2) {								// 获取最后两个参数,p1为倒数第一个 p2为倒数第二个								ParameterMapping p1 = tempParameterMappingList.remove(size - 1);								ParameterMapping p2 = tempParameterMappingList.remove(size - 2);								// 将参数插入到指定位置								tempParameterMappingList.add((size - 2 - count), p1);								tempParameterMappingList.add((size - 2 - count), p2);							}						}						parameterMappingList = tempParameterMappingList;					}					// parameterMappingList.toString());					BoundSql pageBoundSql = new BoundSql(configuration, pageSql, parameterMappingList, parameter);					// 设置动态参数					for (String key : additionalParameters.keySet()) {						pageBoundSql.setAdditionalParameter(key, additionalParameters.get(key));					}					// 执行分页查询					resultList = executor.query(ms, parameter, RowBounds.DEFAULT, resultHandler, pageKey, pageBoundSql);				} else {					// 不执行分页的情况下，也不执行内存分页					resultList = executor.query(ms, parameter, RowBounds.DEFAULT, resultHandler, cacheKey, boundSql);				}			} else {				// rowBounds用参数值，不使用分页插件处理时，仍然支持默认的内存分页				resultList = executor.query(ms, parameter, rowBounds, resultHandler, cacheKey, boundSql);			}			return dialect.afterPage(resultList, parameter, rowBounds);		} finally 		{			dialect.afterAll();		}	} 	/**	 * 执行手动设置的 count 查询，该查询支持的参数必须和被分页的方法相同	 *	 * @param executor	 * @param countMs	 * @param parameter	 * @param boundSql	 * @param resultHandler	 * @return	 * @throws IllegalAccessException	 * @throws SQLException	 */	private Long executeManualCount(Executor executor, MappedStatement countMs, Object parameter, BoundSql boundSql,			ResultHandler resultHandler) throws IllegalAccessException, SQLException {		CacheKey countKey = executor.createCacheKey(countMs, parameter, RowBounds.DEFAULT, boundSql);		BoundSql countBoundSql = countMs.getBoundSql(parameter);		Object countResultList = executor.query(countMs, parameter, RowBounds.DEFAULT, resultHandler, countKey,				countBoundSql);		Long count = ((Number) ((List) countResultList).get(0)).longValue();		return count;	} 	/**	 * 执行自动生成的 count 查询	 *	 * @param executor	 * @param countMs	 * @param parameter	 * @param boundSql	 * @param rowBounds	 * @param resultHandler	 * @return	 * @throws IllegalAccessException	 * @throws SQLException	 */	private Long executeAutoCount(Executor executor, MappedStatement countMs, Object parameter, BoundSql boundSql,			RowBounds rowBounds, ResultHandler resultHandler) throws IllegalAccessException, SQLException {		Map<String, Object> additionalParameters = (Map<String, Object>) additionalParametersField.get(boundSql);		// 创建 count 查询的缓存 key		CacheKey countKey = executor.createCacheKey(countMs, parameter, RowBounds.DEFAULT, boundSql);		// 调用方言获取 count sql		String countSql = dialect.getCountSql(countMs, boundSql, parameter, rowBounds, countKey);		// countKey.update(countSql);		BoundSql countBoundSql = new BoundSql(countMs.getConfiguration(), countSql, boundSql.getParameterMappings(),				parameter);		// 当使用动态 SQL 时，可能会产生临时的参数，这些参数需要手动设置到新的 BoundSql 中		for (String key : additionalParameters.keySet()) {			countBoundSql.setAdditionalParameter(key, additionalParameters.get(key));		}		// 执行 count 查询		Object countResultList = executor.query(countMs, parameter, RowBounds.DEFAULT, resultHandler, countKey,				countBoundSql);		Long count = (Long) ((List) countResultList).get(0);		return count;	} 	/**	 * 尝试获取已经存在的在 MS，提供对手写count和page的支持	 *	 * @param configuration	 * @param msId	 * @return	 */	private MappedStatement getExistedMappedStatement(Configuration configuration, String msId) {		MappedStatement mappedStatement = null;		try {			mappedStatement = configuration.getMappedStatement(msId, false);		} catch (Throwable t) {			// ignore		}		return mappedStatement;	} 	@Override	public Object plugin(Object target) {		// TODO Spring bean 方式配置时，如果没有配置属性就不会执行下面的 setProperties		// 方法，就不会初始化，因此考虑在这个方法中做一次判断和初始化		// TODO https://github.com/pagehelper/Mybatis-PageHelper/issues/26		return Plugin.wrap(target, this);	} 	@Override	public void setProperties(Properties properties) {		// 缓存 count ms		msCountMap = CacheFactory.createCache(properties.getProperty("msCountCache"), "ms", properties);		String dialectClass = properties.getProperty("dialect");		if (StringUtil.isEmpty(dialectClass)) {			dialectClass = default_dialect_class;		}		try {			Class<?> aClass = Class.forName(dialectClass);			dialect = (Dialect) aClass.newInstance();		} catch (Exception e) {			throw new PageException(e);		}		dialect.setProperties(properties); 		String countSuffix = properties.getProperty("countSuffix");		if (StringUtil.isNotEmpty(countSuffix)) {			this.countSuffix = countSuffix;		} 		try {			// 反射获取 BoundSql 中的 additionalParameters 属性			additionalParametersField = BoundSql.class.getDeclaredField("additionalParameters");			additionalParametersField.setAccessible(true);		} catch (NoSuchFieldException e) {			throw new PageException(e);		}	} 	static class PageSqlResolver { 		public static final String SQL_SIGN = "AS limitable"; 		public static final String LIMIT_SIGN = "LIMIT ?"; 		public static final String LIMIT_SIGN_EX = "LIMIT ?, ?"; 		public static String resolveLimit(String pageSql, String changer) {			if (pageSql == null) {				return null;			} 			if (pageSql.contains(SQL_SIGN)) {// 如果需要特殊分页 				pageSql = pageSql.replace(changer, "");				StringBuilder sqlBuilder = new StringBuilder(pageSql); 				StringBuilder mae = new StringBuilder(sqlBuilder.substring(0, sqlBuilder.indexOf(SQL_SIGN)));// mae																												// limitable				StringBuilder uShiRo = new StringBuilder(						sqlBuilder.substring(sqlBuilder.indexOf(SQL_SIGN), sqlBuilder.length()));// 剩余的 				mae.insert(mae.lastIndexOf(")"), String.format(" %s", changer)); 				return mae.append(uShiRo).toString();			} else {				return pageSql;			}		} 	}}
```

​       三:用法同pagehelper正常用法. 拦截器定义为自定义拦截器即可.

 

参考引用  :

https://blog.csdn.net/anurnomeru/article/details/80649561
支持连表等复杂查询的PageHelper修改 —— 支持PageHelper5.1.4 Mybatis3.4.6

https://www.aliyun.com/jiaocheng/773351.html  
支持连表查询之类的复杂查询的PageHelper修改





总结：拦截器实现,分页很大的时候，分页效率可能低；（ limit执行策略的是懒惰查询，limit 1效率高,因为只查1条）因为当分页特别大的时候，limit的offsent偏移值就特别大，例如limit 100000,10，则sql至少要查询100010条，然后返回10条给结果集；  