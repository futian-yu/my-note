### MVCC能否解决幻读？

#### 1、当前读和快照读

​		1）当前读：insert、delete、update、select ... for update(加了写锁/排它锁)、select ... lock in share mode(读锁/共享锁)
​		2）快照读：单纯的select...；平时大多都是快照读。



#### 2、间隙锁

​		当前读的时候有时会产生间隙锁，比如说delete一个where不存在的值，会产生离他最近的左右区间范围的间隙锁，左开右闭。比如说select * from ... where class_id>100  for update.会产生离100左开右闭范围的间隙锁，如数据库只有class_id为1....100的值，锁住的区间就是(100,+无穷大）。



#### 3、结论

- 在“快照读"的情况下是可以解决“幻读”的问题的。使用的就是MVCC，但是读的使历史版本的数据。

- 在默认隔离级别REPEATABLE READ下，同一事务的所有一致性读只会读取第一次查询时创建的快照。一致性读是通过 MVCC 为查询提供了一个基于时间的点的快照。这个查询只能看到在自己之前提交的数据，而在查询开始之后提交的数据是不可以看到的。一个特例是,这个查询可以看到于自己开始之后的同一个事务产生的变化。这个特例会产生一些反常的现象。（特例：beginA:  beginB: commitB: commitA;这样子B的提交A也可以看到）

- Read Repeatable隔离级别：开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读。

- MySQL InnoDB的可重复读并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是next-key locks。要完全避免，需要手动加锁将快照读调整为当前读（mysql不会自动加锁）。



#### 参考文献

[MVCC能否解决幻读](https://www.cnblogs.com/xuwc/p/13873293.html)

