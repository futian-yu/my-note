**每日两道算法题**

- 2021年10月20日

```java
//1.twosum(1)	===================================================
	问题描述：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
	1)暴力解法 ： 嵌套双重循环
	2)散列表解法：使用散列表，借助hashmap.containsKey()方法.nums[i]依次往hashmap里面丢。
	// 按照上述流程，代码如下
    public int[] twosum(int[] nums, int target){
        // 用于存储数组值（key）和下标（value） 
        HashMap<Integer, Integer> record = new HashMap<>();
        // 存储结果下标数组
        int[] res = new int[2];
        // 开始遍历
        for (int i = 0; i <nums.length ; i++) {
            // 目标与当前值差值
            int complement = target - nums[i];
            // 判断map中是否存在差值
            if(record.containsKey(complement)){
                // 保存当前下标，并退出
                res[0] = i;
                res[1] = record.get(complement);
                break;
            }
            // 将当前值存入hash中
            record.put(nums[i], i);
        }
        return res;
     }



//2.twosum问题：输入不存在相同数，但输出的对数不唯一 =============================

整数数组 nums 中有多对整数相加可以得到 target，根据①的实现方式，只要遍历完整个数组即可。

代码如下：时间复杂度 O(n)，空间复杂度 O(n)

public ArrayList<int[]> twosum_output_contain_duplication(int[] nums, int target){
        // 存储输出结果
        ArrayList<int[]> arrayList = new ArrayList<>();
        // 值和下标的映射
        HashMap<Integer, Integer> hashMap = new HashMap<>();
        for (int i = 0; i < nums.length ; i++) {
            int t = target - nums[i];
            if(hashMap.containsKey(t)){
                // 添加目标值
                int[] res = new int[2];
                res[0] = i;
                res[1] = hashMap.get(t);
                // 保存输出结果
                arrayList.add(res);
            }
            hashMap.put(nums[i], i);
        }
        return arrayList;
    }


```

