**每日两道算法题**

- ###### 2021年10月20日 (twosum问题)

```java
//1.twosum(1)	===================================================
	问题描述：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
	1)暴力解法 ： 嵌套双重循环
	2)散列表解法：使用散列表，借助hashmap.containsKey()方法.nums[i]依次往hashmap里面丢。
	// 按照上述流程，代码如下
    public int[] twosum(int[] nums, int target){
        // 用于存储数组值（key）和下标（value） 
        HashMap<Integer, Integer> record = new HashMap<>();
        // 存储结果下标数组
        int[] res = new int[2];
        // 开始遍历
        for (int i = 0; i <nums.length ; i++) {
            // 目标与当前值差值
            int complement = target - nums[i];
            // 判断map中是否存在差值
            if(record.containsKey(complement)){
                // 保存当前下标，并退出
                res[0] = i;
                res[1] = record.get(complement);
                break;
            }
            // 将当前值存入hash中
            record.put(nums[i], i);
        }
        return res;
     }



//2.twosum问题：输入不存在相同数，但输出的对数不唯一 =============================

整数数组 nums 中有多对整数相加可以得到 target，根据①的实现方式，只要遍历完整个数组即可。

代码如下：时间复杂度 O(n)，空间复杂度 O(n)

public ArrayList<int[]> twosum_output_contain_duplication(int[] nums, int target){
        // 存储输出结果
        ArrayList<int[]> arrayList = new ArrayList<>();
        // 值和下标的映射
        HashMap<Integer, Integer> hashMap = new HashMap<>();
        for (int i = 0; i < nums.length ; i++) {
            int t = target - nums[i];
            if(hashMap.containsKey(t)){
                // 添加目标值
                int[] res = new int[2];
                res[0] = i;
                res[1] = hashMap.get(t);
                // 保存输出结果
                arrayList.add(res);
            }
            hashMap.put(nums[i], i);
        }
        return arrayList;
    }


```



- ###### 2021年10月21日 （冒泡排序、快速排序、堆排序、归并排序）

**问题：数据量较大时用什么排序方法比较好？**

​	   普遍认为：当N很小时，快速排序慢，归并排序快 ；当N很大时，并且有序程度高时，快速排序最快； 当N很大时，并且有序程序低时，堆排序最快。

​		快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；
​		堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。
​		若要求排序稳定，则可选用归并排序。先利用直接插入排序求得较长的有序子文件，然后再两两归并之。因为直接插入排序是稳定的，所以改进后的归并排序仍是稳定的。

​	  但是：由于快速排序不稳定，因此数据量极大时不如选用堆排序。

```java
//1.冒泡排序	==================================================
1）比较相邻的元素。如果第一个比第二个大，就交换它们两个；
2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
3）针对所有的元素重复以上的步骤，除了最后一个；
4）重复步骤1~3，直到排序完成。
	/**
      * 冒泡排序
      *
      * @param array
      * @return
      */
     public static int[] bubbleSort(int[] array) {
         if (array.length == 0)
             return array;
         for (int i = 0; i < array.length; i++)
             for (int j = 0; j < array.length - 1 - i; j++)
                 if (array[j + 1] < array[j]) {
                     int temp = array[j + 1];
                     array[j + 1] = array[j];
                     array[j] = temp;
                 }
         return array;
     }

//2.快速排序	==================================================
快速排序采用分而治之的思想，主要步骤分为以下几步：
	1）从数列中挑出一个元素，称为 "基准"（pivot）;
	2）重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
	3）递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；
	
	int[] Quicksort(int[] array,int L,int R){
		if(L>R){return;}
		int left = L;int right = R;
		int pivot = array[left];
		while(left<right){
			while(left<right&&array[right]>=pivot){
				right--;
			}
			if(left<right){
				array[left]=array[right];			
			}
			while(left<right&&array[left]<=pivot){
				left++;
			}
			if(left<right){
				array[right]=array[left];
			}
			if(left>=right){
				array[left]=pivot;
			}		
		}
		Quicksort(array,L,right-1);
		Quicksort(array,right+1,R);
	}

//3.堆排序	     ==================================================
弄清楚什么是堆：完全二叉树&&父节点的值全都大于子节点的值。
答案：https://www.cnblogs.com/guoyaohua/p/8600214.html

//4.归并排序	==================================================
解题思路：
1、申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2、设定两个指针，最初位置分别为两个已经排序序列的起始位置
3、比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4、重复步骤3直到某一指针达到序列尾
5、将另一序列剩下的所有元素直接复制到合并序列尾
答案：
https://blog.csdn.net/apei830/article/details/6591632

```



- ###### 2021年10月22日

```java
//1.字符串中的第一个唯一字符（简单）
	题目描述：给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。【示例：s = "leetcode"，返回 0；s = "loveleetcode"，返回 2。】
	思路与算法(出现和次数有关的，不要犹豫，用hashMap);
/***
	我们可以对字符串进行两次遍历。
	在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数(这里要熟悉hashMap的getOrDefault(a,"默认值")方法)。在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回它的索引，否则在遍历结束后返回 -1−1。
*/
	class Solution {
    public int firstUniqChar(String s) {
        Map<Character, Integer> frequency = new HashMap<Character, Integer>();
        for (int i = 0; i < s.length(); ++i) {
            char ch = s.charAt(i);
            frequency.put(ch, frequency.getOrDefault(ch, 0) + 1);
        }
        for (int i = 0; i < s.length(); ++i) {
            if (frequency.get(s.charAt(i)) == 1) {
                return i;
            }
        }
        return -1;
    }
}

//2.有效的括号（简单）
	题目描述：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

示例 1：
输入：s = "()"
输出：true
示例 2：
输入：s = "()[]{}"
输出：true
示例 3：
输入：s = "(]"
输出：false
示例 4：
输入：s = "([)]"
输出：false
示例 5：
输入：s = "{[]}"
输出：true
提示
1 <= s.length <= 104
s 仅由括号 '()[]{}' 组成

思路：利用栈+哈希表来解决。哈希表将右括号作为键,左括号作为值；利用hashMap.containsKey(x)来找到第一个右括号，然后匹配压入的栈的第一个值，匹配得上就出栈，匹配不上就返回false.->stack空了

class Solution {
    public boolean isValid(String s) {
        int n = s.length();
        if (n % 2 == 1) {
            return false;
        }

        Map<Character, Character> pairs = new HashMap<Character, Character>() {{
            put(')', '(');
            put(']', '[');
            put('}', '{');
        }};
        Deque<Character> stack = new LinkedList<Character>();
        for (int i = 0; i < n; i++) {
            char ch = s.charAt(i);
            if (pairs.containsKey(ch)) {
                if (stack.isEmpty() || stack.peek() != pairs.get(ch)) {
                    return false;
                }
                stack.pop();
            } else {
                stack.push(ch);
            }
        }
        return stack.isEmpty();
    }
}

```





































