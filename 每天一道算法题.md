**每日两道算法题**

- 2021年10月20日 (twosum问题)

```java
//1.twosum(1)	===================================================
	问题描述：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
	1)暴力解法 ： 嵌套双重循环
	2)散列表解法：使用散列表，借助hashmap.containsKey()方法.nums[i]依次往hashmap里面丢。
	// 按照上述流程，代码如下
    public int[] twosum(int[] nums, int target){
        // 用于存储数组值（key）和下标（value） 
        HashMap<Integer, Integer> record = new HashMap<>();
        // 存储结果下标数组
        int[] res = new int[2];
        // 开始遍历
        for (int i = 0; i <nums.length ; i++) {
            // 目标与当前值差值
            int complement = target - nums[i];
            // 判断map中是否存在差值
            if(record.containsKey(complement)){
                // 保存当前下标，并退出
                res[0] = i;
                res[1] = record.get(complement);
                break;
            }
            // 将当前值存入hash中
            record.put(nums[i], i);
        }
        return res;
     }



//2.twosum问题：输入不存在相同数，但输出的对数不唯一 =============================

整数数组 nums 中有多对整数相加可以得到 target，根据①的实现方式，只要遍历完整个数组即可。

代码如下：时间复杂度 O(n)，空间复杂度 O(n)

public ArrayList<int[]> twosum_output_contain_duplication(int[] nums, int target){
        // 存储输出结果
        ArrayList<int[]> arrayList = new ArrayList<>();
        // 值和下标的映射
        HashMap<Integer, Integer> hashMap = new HashMap<>();
        for (int i = 0; i < nums.length ; i++) {
            int t = target - nums[i];
            if(hashMap.containsKey(t)){
                // 添加目标值
                int[] res = new int[2];
                res[0] = i;
                res[1] = hashMap.get(t);
                // 保存输出结果
                arrayList.add(res);
            }
            hashMap.put(nums[i], i);
        }
        return arrayList;
    }


```



- 2021年10月21日 （冒泡排序、快速排序、堆排序、归并排序）

**问题：数据量较大时用什么排序方法比较好？**

​	   普遍认为：当N很小时，快速排序慢，归并排序快 ；当N很大时，并且有序程度高时，快速排序最快； 当N很大时，并且有序程序低时，堆排序最快。

​		快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；
​		堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。
​		若要求排序稳定，则可选用归并排序。先利用直接插入排序求得较长的有序子文件，然后再两两归并之。因为直接插入排序是稳定的，所以改进后的归并排序仍是稳定的。

​	  但是：由于快速排序不稳定，因此数据量极大时不如选用堆排序。

```java
//1.冒泡排序	==================================================
1）比较相邻的元素。如果第一个比第二个大，就交换它们两个；
2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
3）针对所有的元素重复以上的步骤，除了最后一个；
4）重复步骤1~3，直到排序完成。
	/**
      * 冒泡排序
      *
      * @param array
      * @return
      */
     public static int[] bubbleSort(int[] array) {
         if (array.length == 0)
             return array;
         for (int i = 0; i < array.length; i++)
             for (int j = 0; j < array.length - 1 - i; j++)
                 if (array[j + 1] < array[j]) {
                     int temp = array[j + 1];
                     array[j + 1] = array[j];
                     array[j] = temp;
                 }
         return array;
     }

//2.快速排序	==================================================
快速排序采用分而治之的思想，主要步骤分为以下几步：
	1）从数列中挑出一个元素，称为 "基准"（pivot）;
	2）重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
	3）递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；
	
	int[] Quicksort(int[] array,int L,int R){
		if(L>R){return;}
		int left = L;int right = R;
		int pivot = array[left];
		while(left<right){
			while(left<right&&array[right]>=pivot){
				right--;
			}
			if(left<right){
				array[left]=array[right];			
			}
			while(left<right&&array[left]<=pivot){
				left++;
			}
			if(left<right){
				array[right]=array[left];
			}
			if(left>=right){
				array[left]=pivot;
			}		
		}
		Quicksort(array,L,right-1);
		Quicksort(array,right+1,R);
	}

//3.堆排序	     ==================================================


//4.归并排序	==================================================
```







































