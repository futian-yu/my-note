**每日两道算法题**

# **00Hash相关**

- ###### 2021年10月20日 (twosum问题)

```java
//1.twosum(1)	===================================================
	问题描述：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
	1)暴力解法 ： 嵌套双重循环
	2)散列表解法：使用散列表，借助hashmap.containsKey()方法.nums[i]依次往hashmap里面丢。
	// 按照上述流程，代码如下
    public int[] twosum(int[] nums, int target){
        // 用于存储数组值（key）和下标（value） 
        HashMap<Integer, Integer> record = new HashMap<>();
        // 存储结果下标数组
        int[] res = new int[2];
        // 开始遍历
        for (int i = 0; i <nums.length ; i++) {
            // 目标与当前值差值
            int complement = target - nums[i];
            // 判断map中是否存在差值
            if(record.containsKey(complement)){
                // 保存当前下标，并退出
                res[0] = i;
                res[1] = record.get(complement);
                break;
            }
            // 将当前值存入hash中
            record.put(nums[i], i);
        }
        return res;
     }



//2.twosum问题：输入不存在相同数，但输出的对数不唯一 =============================

整数数组 nums 中有多对整数相加可以得到 target，根据①的实现方式，只要遍历完整个数组即可。

代码如下：时间复杂度 O(n)，空间复杂度 O(n)

public ArrayList<int[]> twosum_output_contain_duplication(int[] nums, int target){
        // 存储输出结果
        ArrayList<int[]> arrayList = new ArrayList<>();
        // 值和下标的映射
        HashMap<Integer, Integer> hashMap = new HashMap<>();
        for (int i = 0; i < nums.length ; i++) {
            int t = target - nums[i];
            if(hashMap.containsKey(t)){
                // 添加目标值
                int[] res = new int[2];
                res[0] = i;
                res[1] = hashMap.get(t);
                // 保存输出结果
                arrayList.add(res);
            }
            hashMap.put(nums[i], i);
        }
        return arrayList;
    }


```



- ###### 2021年10月21日 （冒泡排序、快速排序、堆排序、归并排序）

**问题：数据量较大时用什么排序方法比较好？**

​	   普遍认为：当N很小时，快速排序慢，归并排序快 ；当N很大时，并且有序程度高时，快速排序最快； 当N很大时，并且有序程序低时，堆排序最快。

​		快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；
​		堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。
​		若要求排序稳定，则可选用归并排序。先利用直接插入排序求得较长的有序子文件，然后再两两归并之。因为直接插入排序是稳定的，所以改进后的归并排序仍是稳定的。

​	  但是：由于快速排序不稳定，因此数据量极大时不如选用堆排序。

```java
//1.冒泡排序	==================================================
1）比较相邻的元素。如果第一个比第二个大，就交换它们两个；
2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
3）针对所有的元素重复以上的步骤，除了最后一个；
4）重复步骤1~3，直到排序完成。
	/**
      * 冒泡排序
      *
      * @param array
      * @return
      */
     public static int[] bubbleSort(int[] array) {
         if (array.length == 0)
             return array;
         for (int i = 0; i < array.length; i++)
             for (int j = 0; j < array.length - 1 - i; j++)
                 if (array[j + 1] < array[j]) {
                     int temp = array[j + 1];
                     array[j + 1] = array[j];
                     array[j] = temp;
                 }
         return array;
     }

//2.快速排序	==================================================
快速排序采用分而治之的思想，主要步骤分为以下几步：
	1）从数列中挑出一个元素，称为 "基准"（pivot）;
	2）重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
	3）递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；
	
	int[] Quicksort(int[] array,int L,int R){
		if(L>R){return;}
		int left = L;int right = R;
		int pivot = array[left];
		while(left<right){
			while(left<right&&array[right]>=pivot){
				right--;
			}
			if(left<right){
				array[left]=array[right];			
			}
			while(left<right&&array[left]<=pivot){
				left++;
			}
			if(left<right){
				array[right]=array[left];
			}
			if(left>=right){
				array[left]=pivot;
			}		
		}
		Quicksort(array,L,right-1);
		Quicksort(array,right+1,R);
	}

//3.堆排序	     ==================================================
弄清楚什么是堆：完全二叉树&&父节点的值全都大于子节点的值。
答案：https://www.cnblogs.com/guoyaohua/p/8600214.html

//4.归并排序	==================================================
解题思路：
1、申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2、设定两个指针，最初位置分别为两个已经排序序列的起始位置
3、比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4、重复步骤3直到某一指针达到序列尾
5、将另一序列剩下的所有元素直接复制到合并序列尾
答案：
https://blog.csdn.net/apei830/article/details/6591632

```



- ###### 2021年10月22日(字符串中的第一个唯一字符（简单）、有效的括号（简单）)

```java
//1.字符串中的第一个唯一字符（简单）
	题目描述：给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。【示例：s = "leetcode"，返回 0；s = "loveleetcode"，返回 2。】
	思路与算法(出现和次数有关的，不要犹豫，用hashMap);
/***
	我们可以对字符串进行两次遍历。
	在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数(这里要熟悉hashMap的getOrDefault(a,"默认值")方法)。在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回它的索引，否则在遍历结束后返回 -1−1。
*/
	class Solution {
    public int firstUniqChar(String s) {
        Map<Character, Integer> frequency = new HashMap<Character, Integer>();
        for (int i = 0; i < s.length(); ++i) {
            char ch = s.charAt(i);
            frequency.put(ch, frequency.getOrDefault(ch, 0) + 1);
        }
        for (int i = 0; i < s.length(); ++i) {
            if (frequency.get(s.charAt(i)) == 1) {
                return i;
            }
        }
        return -1;
    }
}

//2.有效的括号（简单）
	题目描述：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

示例 1：
输入：s = "()"
输出：true
示例 2：
输入：s = "()[]{}"
输出：true
示例 3：
输入：s = "(]"
输出：false
示例 4：
输入：s = "([)]"
输出：false
示例 5：
输入：s = "{[]}"
输出：true
提示
1 <= s.length <= 104
s 仅由括号 '()[]{}' 组成

思路：利用栈+哈希表来解决。哈希表将右括号作为键,左括号作为值；利用hashMap.containsKey(x)来找到第一个右括号，然后匹配压入的栈的第一个值，匹配得上就出栈，匹配不上就返回false.->stack空了

class Solution {
    public boolean isValid(String s) {
        int n = s.length();
        if (n % 2 == 1) {
            return false;
        }

        Map<Character, Character> pairs = new HashMap<Character, Character>() {{
            put(')', '(');
            put(']', '[');
            put('}', '{');
        }};
        Deque<Character> stack = new LinkedList<Character>();
        for (int i = 0; i < n; i++) {
            char ch = s.charAt(i);
            if (pairs.containsKey(ch)) {
                if (stack.isEmpty() || stack.peek() != pairs.get(ch)) {
                    return false;
                }
                stack.pop();
            } else {
                stack.push(ch);
            }
        }
        return stack.isEmpty();
    }
}

```



- **2021年10月23日(最小栈(简单)、q316去除重复字母（困难）)**

```java
//1.最小栈(简单)==================================================
题目描述：设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。

示例:
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]
输出：
[null,null,null,null,-3,null,0,-2]
解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.

提示：
pop、top 和 getMin 操作总是在 非空栈 上调用。

class MinStack {
    Deque<Integer> xStack;
    Deque<Integer> minStack;

    public MinStack() {
        xStack = new LinkedList<Integer>();
        minStack = new LinkedList<Integer>();
        minStack.push(Integer.MAX_VALUE);
    }
    
    public void push(int x) {
        xStack.push(x);
        minStack.push(Math.min(minStack.peek(), x));
    }
    
    public void pop() {
        xStack.pop();
        minStack.pop();
    }
    
    public int top() {
        return xStack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}


//2.q316去除重复字母（困难）
题目描述：给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

示例 1：
输入：s = "bcabc"
输出："abc"
示例 2：
输入：s = "cbacdcbc"
输出："acdb"

提示：
1 <= s.length <= 104
s 由小写英文字母组成

题解：贪心 + 单调栈

```



- **2021年10月24日（q224_基本计算器（困难）、q32_最长有效括号（困难））**

```java
//1.q224_基本计算器（困难）
题目描述：给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。

示例 1：
输入：s = "1 + 1"
输出：2
示例 2：
输入：s = " 2-1 + 2 "
输出：3
示例 3：
输入：s = "(1+(4+5+2)-3)+(6+8)"
输出：23
 
提示：
1 <= s.length <= 3 * 105
s 由数字、'+'、'-'、'('、')'、和 ' ' 组成
s 表示一个有效的表达式

思路：括号展开+栈
class Solution {
    public int calculate(String s) {
        Deque<Integer> ops = new LinkedList<Integer>();
        ops.push(1);
        int sign = 1;

        int ret = 0;
        int n = s.length();
        int i = 0;
        while (i < n) {
            if (s.charAt(i) == ' ') {
                i++;
            } else if (s.charAt(i) == '+') {
                sign = ops.peek();
                i++;
            } else if (s.charAt(i) == '-') {
                sign = -ops.peek();
                i++;
            } else if (s.charAt(i) == '(') {
                ops.push(sign);
                i++;
            } else if (s.charAt(i) == ')') {
                ops.pop();
                i++;
            } else {
                long num = 0;
                while (i < n && Character.isDigit(s.charAt(i))) {
                    num = num * 10 + s.charAt(i) - '0';
                    i++;
                }
                ret += sign * num;
            }
        }
        return ret;
    }
}


//2.q32_最长有效括号（困难）
题目描述：给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

示例 1：
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
示例 2：
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
示例 3：
输入：s = ""
输出：0
 
提示：
0 <= s.length <= 3 * 104
s[i] 为 '(' 或 ')'

思路：方法一 动态规划、方法二 栈 

    class Solution {
    public int longestValidParentheses(String s) {
        int maxans = 0;
        Deque<Integer> stack = new LinkedList<Integer>();
        stack.push(-1);
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                stack.push(i);
            } else {
                stack.pop();
                if (stack.isEmpty()) {
                    stack.push(i);
                } else {
                    maxans = Math.max(maxans, i - stack.peek());
                }
            }
        }
        return maxans;
    }
}
    
```



# **00堆相关**

- **2021年10月25日(q295_数据流的中位数（困难）、q480_滑动窗口的中位数（困难）)**

```java
//1.q295_数据流的中位数（困难）
题目描述：中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。
例如，
[2,3,4]?的中位数是 3
[2,3] 的中位数是 (2 + 3) / 2 = 2.5
设计一个支持以下两种操作的数据结构：
void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。
示例：
addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3) 
findMedian() -> 2
答案：看不太懂



//2.q480_滑动窗口的中位数（困难）
困难的暂时先跳过



```

























