**每日两道算法题**

## 00Hash相关

- ###### 2021年10月20日 (twosum问题)

```java
//1.twosum(1)	===================================================
	问题描述：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
	1)暴力解法 ： 嵌套双重循环
	2)散列表解法：使用散列表，借助hashmap.containsKey()方法.nums[i]依次往hashmap里面丢。
	// 按照上述流程，代码如下
    public int[] twosum(int[] nums, int target){
        // 用于存储数组值（key）和下标（value） 
        HashMap<Integer, Integer> record = new HashMap<>();
        // 存储结果下标数组
        int[] res = new int[2];
        // 开始遍历
        for (int i = 0; i <nums.length ; i++) {
            // 目标与当前值差值
            int complement = target - nums[i];
            // 判断map中是否存在差值
            if(record.containsKey(complement)){
                // 保存当前下标，并退出
                res[0] = i;
                res[1] = record.get(complement);
                break;
            }
            // 将当前值存入hash中
            record.put(nums[i], i);
        }
        return res;
     }



//2.twosum问题：输入不存在相同数，但输出的对数不唯一 =============================

整数数组 nums 中有多对整数相加可以得到 target，根据①的实现方式，只要遍历完整个数组即可。

代码如下：时间复杂度 O(n)，空间复杂度 O(n)

public ArrayList<int[]> twosum_output_contain_duplication(int[] nums, int target){
        // 存储输出结果
        ArrayList<int[]> arrayList = new ArrayList<>();
        // 值和下标的映射
        HashMap<Integer, Integer> hashMap = new HashMap<>();
        for (int i = 0; i < nums.length ; i++) {
            int t = target - nums[i];
            if(hashMap.containsKey(t)){
                // 添加目标值
                int[] res = new int[2];
                res[0] = i;
                res[1] = hashMap.get(t);
                // 保存输出结果
                arrayList.add(res);
            }
            hashMap.put(nums[i], i);
        }
        return arrayList;
    }


```



- ###### 2021年10月21日 （冒泡排序、快速排序、堆排序、归并排序）

**问题：数据量较大时用什么排序方法比较好？**

​	   普遍认为：当N很小时，快速排序慢，归并排序快 ；当N很大时，并且有序程度高时，快速排序最快； 当N很大时，并且有序程序低时，堆排序最快。

​		快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；
​		堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。
​		若要求排序稳定，则可选用归并排序。先利用直接插入排序求得较长的有序子文件，然后再两两归并之。因为直接插入排序是稳定的，所以改进后的归并排序仍是稳定的。

​	  但是：由于快速排序不稳定，因此数据量极大时不如选用堆排序。

```java
//1.冒泡排序	==================================================
1）比较相邻的元素。如果第一个比第二个大，就交换它们两个；
2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
3）针对所有的元素重复以上的步骤，除了最后一个；
4）重复步骤1~3，直到排序完成。
	/**
      * 冒泡排序
      *
      * @param array
      * @return
      */
     public static int[] bubbleSort(int[] array) {
         if (array.length == 0)
             return array;
         for (int i = 0; i < array.length; i++)
             for (int j = 0; j < array.length - 1 - i; j++)
                 if (array[j + 1] < array[j]) {
                     int temp = array[j + 1];
                     array[j + 1] = array[j];
                     array[j] = temp;
                 }
         return array;
     }

//2.快速排序	==================================================
快速排序采用分而治之的思想，主要步骤分为以下几步：
	1）从数列中挑出一个元素，称为 "基准"（pivot）;
	2）重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
	3）递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；
	
	@Override
    public int[] sort(int[] sourceArray) throws Exception {
        // 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

        return quickSort(arr, 0, arr.length - 1);
    }

    private int[] quickSort(int[] arr, int left, int right) {
        if (left < right) {
            int partitionIndex = partition(arr, left, right);
            quickSort(arr, left, partitionIndex - 1);
            quickSort(arr, partitionIndex + 1, right);
        }
        return arr;
    }

	/**
	* 核心方法。
	*/
    private int partition(int[] arr, int left, int right) {
        // 设定基准值（pivot）
        int pivot = left;
        int index = pivot + 1;
        for (int i = index; i <= right; i++) {
            if (arr[i] < arr[pivot]) {
                swap(arr, i, index);
                index++;
            }
        }
        swap(arr, pivot, index - 1);
        return index - 1;
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

//3.堆排序	     ==================================================
弄清楚什么是堆：完全二叉树&&父节点的值全都大于子节点的值。
答案：https://www.cnblogs.com/guoyaohua/p/8600214.html

//4.归并排序	==================================================
解题思路：
1、申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2、设定两个指针，最初位置分别为两个已经排序序列的起始位置
3、比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4、重复步骤3直到某一指针达到序列尾
5、将另一序列剩下的所有元素直接复制到合并序列尾
答案：
https://blog.csdn.net/apei830/article/details/6591632

```



- ###### 2021年10月22日(字符串中的第一个唯一字符（简单）、有效的括号（简单）)

```java
//1.字符串中的第一个唯一字符（简单）
	题目描述：给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。【示例：s = "leetcode"，返回 0；s = "loveleetcode"，返回 2。】
	思路与算法(出现和次数有关的，不要犹豫，用hashMap);
/***
	我们可以对字符串进行两次遍历。
	在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数(这里要熟悉hashMap的getOrDefault(a,"默认值")方法)。在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回它的索引，否则在遍历结束后返回 -1−1。
*/
	class Solution {
    public int firstUniqChar(String s) {
        Map<Character, Integer> frequency = new HashMap<Character, Integer>();
        for (int i = 0; i < s.length(); ++i) {
            char ch = s.charAt(i);
            frequency.put(ch, frequency.getOrDefault(ch, 0) + 1);
        }
        for (int i = 0; i < s.length(); ++i) {
            if (frequency.get(s.charAt(i)) == 1) {
                return i;
            }
        }
        return -1;
    }
}

//2.有效的括号（简单）
	题目描述：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

示例 1：
输入：s = "()"
输出：true
示例 2：
输入：s = "()[]{}"
输出：true
示例 3：
输入：s = "(]"
输出：false
示例 4：
输入：s = "([)]"
输出：false
示例 5：
输入：s = "{[]}"
输出：true
提示
1 <= s.length <= 104
s 仅由括号 '()[]{}' 组成

思路：利用栈+哈希表来解决。哈希表将右括号作为键,左括号作为值；利用hashMap.containsKey(x)来找到第一个右括号，然后匹配压入的栈的第一个值，匹配得上就出栈，匹配不上就返回false.->stack空了

class Solution {
    public boolean isValid(String s) {
        int n = s.length();
        if (n % 2 == 1) {
            return false;
        }

        Map<Character, Character> pairs = new HashMap<Character, Character>() {{
            put(')', '(');
            put(']', '[');
            put('}', '{');
        }};
        Deque<Character> stack = new LinkedList<Character>();
        for (int i = 0; i < n; i++) {
            char ch = s.charAt(i);
            if (pairs.containsKey(ch)) {
                if (stack.isEmpty() || stack.peek() != pairs.get(ch)) {
                    return false;
                }
                stack.pop();
            } else {
                stack.push(ch);
            }
        }
        return stack.isEmpty();
    }
}

```



- **2021年10月23日(最小栈(简单)、q316去除重复字母（困难）)**

```java
//1.最小栈(简单)==================================================
题目描述：设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。

示例:
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]
输出：
[null,null,null,null,-3,null,0,-2]
解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.

提示：
pop、top 和 getMin 操作总是在 非空栈 上调用。

class MinStack {
    Deque<Integer> xStack;
    Deque<Integer> minStack;

    public MinStack() {
        xStack = new LinkedList<Integer>();
        minStack = new LinkedList<Integer>();
        minStack.push(Integer.MAX_VALUE);
    }
    
    public void push(int x) {
        xStack.push(x);
        minStack.push(Math.min(minStack.peek(), x));
    }
    
    public void pop() {
        xStack.pop();
        minStack.pop();
    }
    
    public int top() {
        return xStack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}




```



## 01堆相关

- **2021年10月25日(q295_数据流的中位数（困难）、q480_滑动窗口的中位数（困难）)**

```java
//3.q215_数组中的第k个最大元素（中等）

//4.q347_前k个高频元素（中等）



```



## 02递归

```java
//1.q21_合并两个有序链表（简单）

//2.q101_对称二叉树（简单）

//3.q104_二叉树的最大深度（简单）

//4.q226_翻转二叉树（简单）

//5.q236_二叉树的最近公共祖先（中等）












```

## 03链表操作

```java
//1.q2_两数相加（中等）

//2.q19_删除链表的倒数第N个节点（中等）

//3.q61_旋转链表（中等）

//4.q138_复制带随机指针的链表（中等）

//5.q206_反转链表（简单）

//6.q92_反转链表II（中等）




```



## 04双指针遍历/滑动窗口

```java
//1.q26_删除排序数组中的重复项（简单）

//2.q121_买卖股票的最佳时机（简单）

//3.q977_有序数组的平方（简单）

//4.q3_无重复字符的最长子串（中等）

//5.q11_盛最多水的容器（中等）

//6.q15_三数之和（中等）

//7.q16_最接近的三数之和（中等----未解决）

//8.q209_长度最小的子数组（中等）

//9.q325. 和等于k的最长子数组长度中等----未解决
//10.q904. 水果成篮中等
//11.q424. 替换后的最长重复字符中等
//12.q713. 乘积小于K的子数组中等




```



## 05快慢指针遍历

```java
● q141_环形链表LinkedList Cycle简单
● q202_快乐数Happy Number简单
● q876_链表的中间结点Middle of the LinkedList简单
142. 环形链表II(寻找环起点)




```



## 06分治法/二分法

```java
33. 搜索旋转排序数组中等
34. 在排序数组中查找元素的第一个和最后一个位置中等---未解决

```



## 07字符串操作

```java
5字符串操作q57
14. 最长公共前缀简单
6. Z字形变换中等
763. 划分字母区间中等


```

## 08数字操作

```java
7. 整数反转简单
9. 回文数简单
172. 阶乘后的零简单
258. 各位相加简单
43. 字符串相乘中等






```

## 09区间合并

```java
56. 合并区间中等
986. 区间列表的交集中等

```

## 10数组操作

```java
581. 最短无序连续子数组简单
54. 螺旋矩阵中等
73. 矩阵置零中等
384. 打乱数组中等
945. 使数组唯一的最小增量中等
```

## 11树的遍历

```java
110. 平衡二叉树简单
107. 二叉树的层次遍历 II简单
637. 二叉树的层平均值简单
111. 二叉树的最小深度简单
112. 路径总和简单
257. 二叉树的所有路径简单
94. 二叉树的中序遍历中等
102. 二叉树的层序遍历中等
144. 二叉树的前序遍历中等
145. 二叉树的后序遍历中等
● 27 二叉树的镜像
● 28. 对称的二叉树
● 34. 二叉树中和为某一值的路径
● 68 二叉树的最近公共祖先
● 54  二叉搜索树的第k大节点
103. 二叉树的锯齿形层次遍历中等
113. 路径总和 II中等

```

## 12二叉搜索树有关

```java
● q98_验证二叉搜索树中等
● q450_删除二叉搜索树中的节点中等
● q701_二叉搜索树中的插入操作中等

```

## 13.字典树（前缀树）

```java
● q648_单词替换中等

```

## 14.回溯法

```java
22. 括号生成中等
40. 组合总和 II中等
78. 子集中等
46. 全排列 &    47. 全排列 II中等
784. 字母大小写全排列中等
494. 目标和中等
```

## 15.动态规划

```java
● q53_最大子序和简单
● q70_爬楼梯简单
● q118_杨辉三角简单
● q5_最长回文子串中等
● q62_不同路径中等
● q64_最小路径和中等
● q300_最长上升子序列中等
● q1143_最长公共子序列中等
● q1277_统计全为1的正方形子矩阵中等
● 01背包问题

● 207.课程表中等
● 210.课程表2中等
● 444.序列重建中等

```













































=================================》算法视频记录

**20220121第一节**

=========>在面算法的时候，可以准备一直笔一张白纸，面试官不会介意，反而会觉得你准备的很充分。

=========>所有的复杂数据结构都是在数组和链表的基础上改进，所以数组和链表基本操作要熟悉。手写。

=========》手写数组和链表的增删改查操作。要很熟悉。

=========》如果面试官出的题目你没有思路，自信点直接说没有思路，面试官会换一道或引导你。

=========》源码不会就直接说没看过这个源码，没关系。

最佳时间复杂度、平均时间复杂度、最坏时间复杂度。O（n）

空间复杂度：S(n)

int[] [] a = new int[] [] {{},{},{}};

不仅要会写，还要会分析时间、空间复杂度(这里占一半)，还要思考有没有优化空间。

**排序我喜欢考快速排序。**

![数组题目](./images/51.jpg)

**字符串考察**(物理结构：可以顺序存储，也可以链式存储)

![](./images/52.jpg)



===========》如果 给一个str类型的输入值呢？需要熟悉str的基本方法。

![也可以使用栈,压栈出栈](./images/53.jpg) 



===========》**链表喜欢考察**：注意链表的结构，是一个Node节点(data+next)

首先链表创建要会定义。(创建的是一个Node节点)

链表增删改查，写的时候最好拿张白纸，把节点和指针给画出来，会更加清晰。

![链表反转](./images/54.jpg)



===========》**队列：先进先出**

===========>**堆栈：**只允许在表的一端进行插入和删除操作的线性表。

堆栈经常使用在：操作系统中的函数调用栈，浏览器中的前进、后退功能，翻转一组元素的顺序、铁路列车车辆调度。

![](./images/55.jpg)



数组的排序：冒泡、选择、插入、快速



===================》2022年2月28日

![](./images/56.jpg)

![](./images/57.jpg)



![](./images/58.jpg)

![](./images/59.jpg)

![](./images/60.jpg)

![](./images/61.jpg)

![](./images/62.jpg)

![](./images/63.jpg)

![](./images/64.jpg)

![](./images/65.jpg)









