**jvm**

1.jvm堆栈总结(栈管运行，堆管存储)

​	1.1 栈存放以下变量

- 存储局部变量【声明在某方法、代码段(比如说for循环)里】，执行到它的时候，会直接在栈中开辟内存,并且当它一旦脱离作用域后，就会立即释放内存。
- 所有原始类型，变量的值也保存在栈中。
- 对于引用类型，栈中保存的是堆中该指向对象的物理地址。



​	1.2 堆存放以下变量

- 存出new出来的对象



2.所有多线程是共享一个堆的，但是每个线程都有自己的一个栈内存，里面存储单独属于该线程的变量。

3.当我们进行编译操作的时候，会生成.class文件，这些文件是保存在电脑硬盘上的。只有当运行的时候，class文件才会被加载到内存中，这个时候，会甄别哪些进栈内存、哪些进堆内存。比如局部变量就进栈内存，new出来的对象就进堆内存【java虚拟机的垃圾回收就是回收堆内存中的内存】。

4.静态变量的声明周期会一直持续到整个”系统“关闭。

5.当你new对象的时候，系统给你的对象分配的不一定是连续的空间（比如说new类对象）；jvm会根据零散的堆内存地址，通过哈希算法换算成一长串数字来表示你整个对象的"物理位置".   当这个实例变量的引用丢失后，也不是立马就释放堆内存的，它会先被垃圾回收器列入可回收名单之内。

6.基本数据类型的值传递，不改变原值，因为调用后就会弹栈，原局部变量就消失了；引用数据类型的值传递，改变原值，因为即时方法弹栈，但是此时我已经知道了该对象的物理地址，并且该对象还在，所以我可以找到它并改变它的值。

7.双亲委派机制：如果一个类加载器收到了类加载的请求，他首先不会自己去加载这个类，而是把这个请求委派给自己的父加载器，每一层都是如此，因此所有的类加载器最终都会传送到顶层的Bootstrap ClassLoader中，只有当父加载器无法完成加载请求时，子加载器才会自己去加载该类。

8.jvm题目-更新

```java
//1.age=20是因为main里的age在栈里,传给外部方法只是传了一个副本；
//2.xxx是因为main里面的对象指向abc,传给外部方法传的是引用，两个都指向同一个堆内存地址“abc”,且外部方法将其改为xxx了，因为两个引用指向的是同一个地址，所以main里面的person对象指向地址的值也为xxx了;
//3.main里的str先去常量池检查有没有abc，没有则创建一个“abc”，在堆中。str指向它，这时候把str引用作为参数传给外部方法，外部方法的引用也指向abc，但是方法内部又检查或创建了一个“xxx”,并且此时外部方法的引用str指向xxx，但是main内部的str引用还是指向abc不变的.
```

![](./images/21.jpg)



===========================2021年9月15日更新=============================

**一、JVM体系结构概览**

![](./images/1/75.jpg)

**二、四种GC**

- **1.引用计数法**

```java
//1.引用计数法
- 优点：一般不采用了
- 缺点：
    * 每次对对象赋值时均需要维护引用计数器，且计数器本身也有一定的消耗；
    * 较难处理循环引用；
/**  JVM的实现一般不采用这种方式  */
可达性分析算法(主流)
	以方法区的静态变量或栈针变量表的变量为Root根节点,通过这个root去找其他下级节点，无法到达的对象在GC中会被清理。
```

![](./images/1/76.jpg)



- **2.复制算法（大多JVM的GC都用这个）**

```java
//优点：GC后的内存空间是连续的。
//缺点：由于分出了Survivor2不存放对象，真正存放新对象的内存区域会变少，Eden:Survivor1:Survivor2比例为8:1:1，少了10%的可用内存。
```

![](./images/1/77.jpg)



- **3.标记清除法**

```java
//优点：简单
//缺点：会产生大量的内存碎片
```

![](./images/1/78.jpg)



- **4.标记整理法**

```java
//既不浪费空间，也不产生碎片，但是耗时间。因为滑动碎片需要时间。
```

![](./images/1/79.jpg)

三、谈谈你对GCRoots的理解

​	jvm寻找垃圾对象，可枚举根节点(GCRoots对象)做可达性分析(根搜索路径)。如下图：

![](./images/1/80.jpg)

![](./images/1/81.jpg)

​	四类可以作为GCRoots对象的东西：

```java
//1.虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
//2.方法区中的类静态属性引用的对象。
//3.方法区中常量引用的对象。
//4.本地方法栈中JNI(Native)引用的对象。
```

四、jvm标配参数、X参数和**XX参数**(https://blog.csdn.net/lixinkuan328/article/details/94505882)

**（1）标配参数（以-开头）**

​	 在JDK各个版本之间稳定，很少有大的变化。

![](./images/1/82.jpg)

**（2）X参数（以-X开头）**

![](./images/1/83.jpg)

**（3）XX参数--只有类2种类型（以-XX开头）**

**【1】Boolean类型XX参数    公式：-XX:+ 或者-XX:- 某个属性值（+表示开启，-表示关闭）**

```java
    案例：

       1）是否打印GC收集细节
               -XX:+PrintGCDetails
               -XX:-PrintGCDetails
        2）是否使用串行垃圾收集器
               -XX:+UseSerialGC
               -XX:-UserSerialGC    
```

![](./images/1/84.jpg)

```java
       jps -l                                           表示查看java运行的进程号
       jinfo -flag PrintGCDetails  pid    表示查看JVM是否配置PrintGCDetails参数
       -XX:-PrintGCDetails                   减号表示没有配置PrintGCDetails参数
```

![](./images/1/85.jpg)

**【2】KV设值类型  公式：-XX: key（属性）= value（属性值）**

```java
// -XX:MetaspaceSize  设置元空间大小。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，在默认情况下，元空间的大小仅受本地内存限制。（元空间默认情况下只用了20.8M左右）
```

![](./images/1/86.jpg)

**二、jinfo查看当前运行程序配置：公式：jinfo -flag 配置项 进程号**

```java
案例：    查看JVM所有配置项（默认+人工配置）
         jinfo -flags 进程号
         Non-default VM flags表示JVM默认参数
         Command line表示人工配置参数
```

![](./images/1/87.jpg)

**三、如何解释-Xms和-Xmx参数属于XX参数**

```java
   -Xms和-Xmx两个经典参数看起既不像Boolean类型XX参数，也不像KV设值类型XX参数。那为什么-Xms和-Xmx又属于XX参数？
       -Xms = -XX:InitialHeapSize
       -Xmx = -XX:MaxHeapSize 
```

**四、盘点家底JVM默认值**
**（1）第一种查看JVM默认值方式**    

```java
jinfo -flag 参数项 进程号
       jinfo -flags 进程号
```

**（2）第二种查看JVM默认值方式**    

```java
公式：java -XX:+PrintFlagsInitial（查看jvm未更改的默认参数）
       公式：java -XX:+PrintFlagsFinal（查看jvm已经更改过的参数）
       :=表示jvm启动时候默认修改或者人工更改过的参数
       =表示jvm没有更改过的默认参数
    uintx InitialHeapSize   := 266338304      {product} 默认为操作系统64/1内存（我本机内存为16G）
```

 ![](./images/1/88.jpg)
**（3）-XX:+PrintCommandLineFlags打印命令行参数**

![](./images/1/89.jpg)

**五、XX参数总结**(要知道主要的几个就行，其他的当作字典来查)

```java
//查看jvm的栈大小：jinfo -flag ThreadStackSize 61156			
//给定栈空间128k的大小配置： -Xss128k    
```

几个主要的需要知道的参数：

![](./images/1/94.jpg)



![](./images/1/90.jpg)

![](./images/1/91.jpg)

![](./images/1/92.jpg)

![](./images/1/93.jpg)



















