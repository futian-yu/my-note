**jvm**

1.jvm堆栈总结(栈管运行，堆管存储)

​	1.1 栈存放以下变量

- 存储局部变量【声明在某方法、代码段(比如说for循环)里】，执行到它的时候，会直接在栈中开辟内存,并且当它一旦脱离作用域后，就会立即释放内存。
- 所有原始类型，变量的值也保存在栈中。
- 对于引用类型，栈中保存的是堆中该指向对象的物理地址。



​	1.2 堆存放以下变量

- 存出new出来的对象



2.所有多线程是共享一个堆的，但是每个线程都有自己的一个栈内存，里面存储单独属于该线程的变量。

3.当我们进行编译操作的时候，会生成.class文件，这些文件是保存在电脑硬盘上的。只有当运行的时候，class文件才会被加载到内存中，这个时候，会甄别哪些进栈内存、哪些进堆内存。比如局部变量就进栈内存，new出来的对象就进堆内存【java虚拟机的垃圾回收就是回收堆内存中的内存】。

4.静态变量的声明周期会一直持续到整个”系统“关闭。

5.当你new对象的时候，系统给你的对象分配的不一定是连续的空间（比如说new类对象）；jvm会根据零散的堆内存地址，通过哈希算法换算成一长串数字来表示你整个对象的"物理位置".   当这个实例变量的引用丢失后，也不是立马就释放堆内存的，它会先被垃圾回收器列入可回收名单之内。

6.基本数据类型的值传递，不改变原值，因为调用后就会弹栈，原局部变量就消失了；引用数据类型的值传递，改变原值，因为即时方法弹栈，但是此时我已经知道了该对象的物理地址，并且该对象还在，所以我可以找到它并改变它的值。

7.双亲委派机制：如果一个类加载器收到了类加载的请求，他首先不会自己去加载这个类，而是把这个请求委派给自己的父加载器，每一层都是如此，因此所有的类加载器最终都会传送到顶层的Bootstrap ClassLoader中，只有当父加载器无法完成加载请求时，子加载器才会自己去加载该类。

8.jvm题目-更新

```java
//1.age=20是因为main里的age在栈里,传给外部方法只是传了一个副本；
//2.xxx是因为main里面的对象指向abc,传给外部方法传的是引用，两个都指向同一个堆内存地址“abc”,且外部方法将其改为xxx了，因为两个引用指向的是同一个地址，所以main里面的person对象指向地址的值也为xxx了;
//3.main里的str先去常量池检查有没有abc，没有则创建一个“abc”，在堆中。str指向它，这时候把str引用作为参数传给外部方法，外部方法的引用也指向abc，但是方法内部又检查或创建了一个“xxx”,并且此时外部方法的引用str指向xxx，但是main内部的str引用还是指向abc不变的.
```

![](./images/21.jpg)



===========================2021年9月15日更新=============================

**一、JVM体系结构概览**

![](./images/1/75.jpg)

**二、四种GC**

- **1.引用计数法**

```java
//1.引用计数法
- 优点：一般不采用了
- 缺点：
    * 每次对对象赋值时均需要维护引用计数器，且计数器本身也有一定的消耗；
    * 较难处理循环引用；
/**  JVM的实现一般不采用这种方式  */
可达性分析算法(主流)
	以方法区的静态变量或栈针变量表的变量为Root根节点,通过这个root去找其他下级节点，无法到达的对象在GC中会被清理。
```

![](./images/1/76.jp)



- **2.复制算法（大多JVM的GC都用这个）**

```java
//优点：GC后的内存空间是连续的。
//缺点：由于分出了Survivor2不存放对象，真正存放新对象的内存区域会变少，Eden:Survivor1:Survivor2比例为8:1:1，少了10%的可用内存。
```

![](./images/1/77.jp)



- **3.标记清除法**

```java
//优点：简单
//缺点：会产生大量的内存碎片
```

![](./images/1/78.jp)



- **4.标记整理法**

```java
//既不浪费空间，也不产生碎片，但是耗时间。因为滑动碎片需要时间。
```

![](./images/1/79.jp)

三、谈谈你对GCRoots的理解

​	jvm寻找垃圾对象，可枚举根节点(GCRoots对象)做可达性分析(根搜索路径)。如下图：

![](./images/1/80.jp)

![](./images/1/81.jp)

​	四类可以作为GCRoots对象的东西：

```java
//1.虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
//2.方法区中的类静态属性引用的对象。
//3.方法区中常量引用的对象。
//4.本地方法栈中JNI(Native)引用的对象。
```

四、jvm标配参数、X参数和**XX参数**































