jvm

1.jvm堆栈总结(栈管运行，堆管存储)

​	1.1 栈存放以下变量

- 存储局部变量【声明在某方法、代码段(比如说for循环)里】，执行到它的时候，会直接在栈中开辟内存,并且当它一旦脱离作用域后，就会立即释放内存。
- 所有原始类型，变量的值也保存在栈中。
- 对于引用类型，栈中保存的是堆中该指向对象的物理地址。



​	1.2 堆存放以下变量

- 存出new出来的对象



2.所有多线程是共享一个堆的，但是每个线程都有自己的一个栈内存，里面存储单独属于该线程的变量。

3.当我们进行编译操作的时候，会生成.class文件，这些文件是保存在电脑硬盘上的。只有当运行的时候，class文件才会被加载到内存中，这个时候，会甄别哪些进栈内存、哪些进堆内存。比如局部变量就进栈内存，new出来的对象就进堆内存【java虚拟机的垃圾回收就是回收堆内存中的内存】。

4.静态变量的声明周期会一直持续到整个”系统“关闭。

5.当你new对象的时候，系统给你的对象分配的不一定是连续的空间（比如说new类对象）；jvm会根据零散的堆内存地址，通过哈希算法换算成一长串数字来表示你整个对象的"物理位置".   当这个实例变量的引用丢失后，也不是立马就释放堆内存的，它会先被垃圾回收器列入可回收名单之内。

6.基本数据类型的值传递，不改变原值，因为调用后就会弹栈，原局部变量就消失了；引用数据类型的值传递，改变原值，因为即时方法弹栈，但是此时我已经知道了该对象的物理地址，并且该对象还在，所以我可以找到它并改变它的值。

7.双亲委派机制：如果一个类加载器收到了类加载的请求，他首先不会自己去加载这个类，而是把这个请求委派给自己的父加载器，每一层都是如此，因此所有的类加载器最终都会传送到顶层的Bootstrap ClassLoader中，只有当父加载器无法完成加载请求时，子加载器才会自己去加载该类。

8.jvm题目

```java
//1.age=20是因为main里的age在栈里,传给外部方法只是传了一个副本；
//2.xxx是因为main里面的对象指向abc,传给外部方法传的是引用，两个都指向同一个堆内存地址“abc”,且外部方法将其改为xxx了，因为两个引用指向的是同一个地址，所以main里面的person对象指向地址的值也为xxx了;
//3.main里的str先去常量池检查有没有abc，没有则创建一个“abc”，在堆中。str指向它，这时候把str引用作为参数传给外部方法，外部方法的引用也指向abc，但是方法内部又检查或创建了一个“xxx”,并且此时外部方法的引用str指向xxx，但是main内部的str引用还是指向abc不变的.
```

![](./images/21.jpg)





























