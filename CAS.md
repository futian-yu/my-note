**CAS**

1.CAS机制有点类似于乐观锁，CAS机制可以理解成一个**多线程争抢资源并且无阻塞**的模型。

2.CAS操作包含三个操作数 —— 内存地址(V)、旧的预期值(A)和即将要更新的值（B）。执行CAS的时候，将内存地址的值与预期值进行比较，如果相同就把内存地址对应的值更新成B；如果不相同，就什么也不做。

3.说说CAS底层原理：（1）自旋锁；（2）Unsafe类.  ===>CAS是原子性的

​	CAS并发原语体现在java语言中就是sun.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，**并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。**==》下面var2不是值，是对象的地址；var2地址最新真实的值与var5进行比较.

![](./images/15.jpg)

4.Unsafe类：

​	首先再看看AtomicInter类，里面用到了Unsafe类。Unsafe是CAS的核心类，由于java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe类相当于一个后门，基于该类可以直接操作特定内存的数据。**Unsafe类存在于sun.misc包中**，其内部方法操作可以像C的指针一样直接操作内存，Java中CAS操作的执行依赖于Unsafe类的方法。

​	**注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务。**

​	下图中的valueOffset，表示该变量在内存中的偏移地址，Unsafe就是直接根据内存偏移地址获取数据的.

​	下图中的value用了volatile修饰，保证了多线程之间的可见性。

![](./images/14.jpg)

![](./images/12.jpg)



