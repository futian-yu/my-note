redis内存淘汰策略

不同的删除策略

```java
//定时删除：
	立即删除能保证内存中数据的最大新鲜度，因为它保证过期键值会在过期后马上被删除，其所占用的内存也会随之释放。但是立即删除对cpu是最不友好的。因为删除操作会占用cpu的时间，如果刚好碰上了cpu很忙的时候，比如正在做交集或者排序计算的时候，就会给cpu造成额外的压力，让cpu心累，时时需要删除，忙死。。。。
这会产生大量的性能消耗，同时也会影响数据的读取操作。
	总结：对cpu不友好，用处理器性能换取存储空间。（拿时间换空间）
//惰性删除：
	数据到达过期时间，不做处理。等下次访问该数据时，如果未过期，返回数据；如果发现已过期，删除，返回不存在。
	惰性删除的缺点是：它对内存是不友好的。（尤其是很少用到的键，可能永远也不会删除。）
	
//以上两种删除方式都走极端，看下面的折中方式
//定期删除
	定期删除策略是前两种策略的折中：
	定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。
	周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除额度。
	特点一：CPU性能占用设置有峰值，检测频度可自定义设置。
	特点二：内存压力不是很大，长期占用内存的冷数据会被持续清理。
	总结：周期性抽查存储空间（随机抽查，重点抽查）。

	举例：
	redis默认每隔100ms检查，是否有过期的key，有过期的key则删除。注意：redis不是每隔100ms将所有的key检查一次而是随机抽取进行检查（如果每隔100ms，全部key进行检查，redis直接进去ICU）。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。（定期删除策略难点是确定删除操作执行的时长和频率：删除太频繁，退化为定时删除策略；删除太少，退化为惰性删除）

```



八大内存淘汰策略（redis内存快打满的时候会自动触发，出厂默认noeviction，生产具体选择看你配置）：

一般来说配置较多的是 ：allkeys-lru

（lru、lfu、random、ttl）





![1636600596279](C:\Users\Yuft\AppData\Roaming\Typora\typora-user-images\1636600596279.png)

lru算法简介（力扣上的中等难度）：

hashMap快，O(1)复杂度就可以获得







