**线程池**

**1.Callable接口**

![](./images/30.jpg)



**2.FutureTask类.**

​	它实现了继承了Runnable接口的子接口，实现了和Runnable接口以及Thread类的耦合关联.使用方法如下图：

![](./images/31.jpg)



**3.线程池的优势？**

![](./images/32.jpg)



**4.线程池的底层用了哪些类和接口？**

​		Java中的线程池是通过Executor框架实现的，该框架用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类。如下图所示：

![](./images/1/52.jpg)



**5.线程池常用的三个方式和底层原理（重点）**

```java
public void test{
    ExecutorService threadPoll = Executors.newFixedThreadPoll(5);//一池5个处理线程,执行长期的任务，性能好很多；
	ExecutorService threadPoll = Executors.newSingleThreadExecutor();//一池一个处理线程,一个任务一个任务执行的场景；
    ExecutorService threadPoll = Executors.newCachedThreadPoll();//一池N个处理线程,适用执行很多短期异步的小程序或者负载较轻的服务器；
}
```

![](./images/1/53.jpg)



**6.线程池的7大参数（重点）**

```java
- 	1）corePoolSize：线程池中的常驻核心线程数；

​	2）maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1；

​	3）keepAliveTime：多余的空闲线程的存活时间。当前线程池数量超过corePoolSize时，当线程空闲时间达到keepAliveTime时，多余空闲线程会被销毁，直到只剩下corePoolSize个线程为止；

​	4）unit：keepAliveTime的单位；

​	5）workQueue：任务队列，被提交但尚未被执行的任务；

​	6）threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程，一般用默认的即可；

​	7）handler：拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数(maximumPoolSize)
```

![线程池7大参数图解](./images/1/54.jpg)

