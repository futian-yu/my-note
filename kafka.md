**kafka**

//kafka是比较适合吞吐量大，快的要求;  RibbitMQ适合低延迟的要求.

//kafka可以做到60/s，每小时200GB/单机，相当牛逼.



**1.kafka速度如何？**

![](./images/40.jpg)



**2.为什么kafka这么快？**

​	**1）集群扩展:生产者多了也就快了.(做集群负载均衡 要先做好)**

​		//既然有分区这一概念，那么生产者每次生产数据该向哪个分区发送？ ==> 常用分区写入策略:轮询分区策略(默认)、随机分区策略、按key分区分配策略、自定义分区策略.

​		//正是因为这个分区的策略，使得kafka只能保证一个分区的消息顺序，多个分区之间不能保证消息的顺序.

​		//消费者可以横向扩展,做好消费分配策略就好（一个消费者消费一个或多个分区,一个分区只能对应一个消费者组里的一个消费者,所以消费者如果比分区数还多，就是一种浪费.一个分区对一个消费者也防止逻辑上消息重复消费.）

​		![](./images/41.jpg)

​		![](./images/42.jpg)

​	**2）零拷贝**

​		//内核空间到用户空间切换非常耗时，以及调用内核函数调用驱动去用户空间处理磁盘数据也耗时.正常情况下的拷贝这里涉及到四次上下文切换:

​		第一次：将磁盘文件，读取到操作系统的内核缓冲区；

​		第二次：将内核缓冲区的数据，copy到application应用程序的buffer；

​		第三次：将application应用程序buffer中的数据，copy到socket网络发送缓冲区(属于操作系统内核的缓冲区);

​		第四次：将socket buffer的数据,copy到网卡，由网卡进行网络传输。

![传统拷贝](./images/43.jpg)

​	![传统拷贝](./images/44.jpg)

如果减少了用户态与核心态之间的切换，是不是就会更快了呢？如下图：

![](./images/45.jpg)

此时我们发现用户态“空空如也”。数据没有来到用户态，而是直接在核心态就进行了传输，但是这样依然还有一次磁盘到内存和两次buffer之间的复制。首先磁盘数据被读取到read buffer中，然后发送到socket buffer，最后才发到网卡。虽然减少了用户态和核心态的切换，但依然存在多次数据复制。如何进一步减少数据复制，甚至没有数据复制而坐到最快呢？===>

**DMA**:全称叫Direct Memory Access，一种可让某些硬件子系统去直接访问系统主内存，而不用依赖CPU的计算机系统的功能。跳过CPU，直接访问主内存，而传统的内存访问都要经过CPU。如下图：

![](./images/46.jpg)

回到零拷贝，借助DMA，直接让网卡访问系统主内存的kafka的READ Buffer数据。如下图:

![](./images/47.jpg)

kafka写入数据的时候，也是写到内核缓冲区，然后操作系统内核负责调度线程把内核缓冲区的数据(脏页)同步到磁盘中.

![](./images/48.jpg)

```java
/**=========java的零拷贝实现=========*/
//在Java中的零拷贝实现是在FileChannel中，其中有个方法transferTo(position,fsize,src)。

//传统的文件传输是通过java.io.DataOutputStream，java.io.FileInputStream来实现的，然后通过while循环来读取input，然后写入到output中。

public class Test{
    String fname="readfile.txt";
    long fsize = 183678375L,sendsize=4094;
    ...
    FileChannel fc = new FileInputStream(fname).getChannel();
    curnset = fc.transferTo(0,fsize,sc);
    ...
}

```

- 零拷贝总结：通过DMA技术网卡直接读取系统主内存的kafka的Read Buffer，减少了拷贝过程中用户态和内核态之间的上下文切换、数据多次无用拷贝消耗的时间。



​	**3）磁盘顺序写**: 在磁盘上读写的速度可能比较慢，因为寻址会比较消耗时间。但是kafka保证了磁盘顺序写，所以寻址消耗的时间可以省去，就非常快了。

​	**4）NIO网络通信**

​	**5）PageCache**

​		kafka写入数据的时候，也是写到内核缓冲区(PageChahe)，然后操作系统内核负责调度线程把内核缓冲区的数据(脏页)同步到磁盘中。写入内核缓冲区这里使用了MMap技术，核心思想是多个用户态的kafka进程把数据写入一个java虚拟内存(可以认为是内核态)，然后跟内核缓冲区进行数据交换与写入，这样就不用在用户态和内核态之间频繁切换上下文。

![](./images/48.jpg)

​	**6）消息压缩**

​			kafkaproducer生产数据到各个partition后，会有一个消息累加器计算消息数量，达到一定数量后，然后再进行分批次的发送。同时再发送过程中会进行一个压缩。

![](./images/1/49.jpg)

















